<h2 class="no_toc text-delta" id="table-of-contents">Table of Contents</h2>

<ol id="markdown-toc">
  <li><a href="#step-detection-algorithm" id="markdown-toc-step-detection-algorithm">Step Detection Algorithm</a></li>
  <li><a href="#implementing-step-counting-in-python" id="markdown-toc-implementing-step-counting-in-python">Implementing Step Counting in Python</a></li>
  <li><a href="#the-find_peaks-function" id="markdown-toc-the-find_peaks-function">The <code class="language-plaintext highlighter-rouge">find_peaks</code> Function</a>    <ol>
      <li><a href="#tuning-parameters-height-prominence-distance-and-width" id="markdown-toc-tuning-parameters-height-prominence-distance-and-width">Tuning Parameters: Height, Prominence, Distance, and Width</a></li>
      <li><a href="#the-role-of-sampling-rate" id="markdown-toc-the-role-of-sampling-rate">The Role of Sampling Rate</a></li>
    </ol>
  </li>
  <li><a href="#notebook-step-counting-with-find-peaks-html-ipynb" id="markdown-toc-notebook-step-counting-with-find-peaks-html-ipynb">Notebook: Step Counting with Find Peaks [html] [ipynb]</a></li>
</ol>
<hr />

<h2 id="step-detection-algorithm">Step Detection Algorithm</h2>

<p>There are many different ways that we can design a step detection algorithm. We outline one such method in this section. The key insight in our method is to convert the 3-axis signal into a one axis magnitude signal, and then extract steps from this signal.</p>

<p><img src="images/image12.png" alt="drawing" width="600" /></p>

<p><em>Figure 5: Step Detection Algorithm</em></p>

<p><strong>Step 1: Extract signal magnitude</strong>: In the previously described algorithm, we selected the axis along which maximum acceleration occurred and focused on that one. Here, we are just going to take the magnitude of the entire acceleration vector i.e.</p>

<p><img src="images/image1.png" alt="drawing" width="100" /></p>

<p>, where x, y, and z are the readings of the accelerometer along the three axes.</p>

<p><img src="images/image5.png" alt="drawing" width="600" /></p>

<p><em>Figure 6: Example showing sources of noise in magnitude signal</em></p>

<p><strong>Step 2: Filter the signal to remove noise</strong>: The second step is to remove noise, and extract the specific signal corresponding to walking. Before we perform this step, we need to know what are the sources of noise. There are several sources of noise that we need to filter out (shown in Figure 6):</p>

<ul>
  <li><strong>Jumpy peaks</strong>: Since the phone is often carried in a pocket/purse, it can jiggle a little with each step. Also, some users have a bounce in their step, so even though they are taking a single step, the phone can bounce multiple times within this step.</li>
  <li><strong>Short peaks</strong>: Small peaks can occur when a user is using a phone (e.g. making a call or using an app).</li>
  <li><strong>Slow peaks</strong>: Slow peaks can occur when the phone is moved or due to movements of the leg while sitting (if the phone is in the pant pocket)</li>
</ul>

<p>To remove these sources of noise, we are going to use frequency-domain noise removal. Notice that we need to remove high frequency variations like jumpy peaks and low frequency variations like slow peaks. A simple solution is to use a filter that keeps only frequencies relating to walking and removes the rest. For example, we know that typical walking pace may be under three steps a second (3 Hz) and over half step a second (0.5Hz), so perhaps we remove all frequencies above 5 Hz and below 0.5 Hz (just to give some margin for error). Note that this method would not be able to detect running or bicycling, which may have higher pace.</p>

<p>Even after we remove low and high frequency peaks, we may be left with some short peaks. A simple way to deal with this is to look only for large peaks and ignore small peaks.</p>

<p float="left">
<img src="images/image6.png" alt="drawing" width="500" />
<img src="images/image10.png" alt="drawing" width="500" />
</p>

<p><em>Figure 7: Zero crossings (left) and peaks (right) of the filtered magnitude signal</em></p>

<p><strong>Step 3: Detecting Steps.</strong> Once you have the smoothed data, let us consider how to detect the step. There are many approaches to do this. We could do what was suggested earlier, which is to look for large peaks and use that to detect steps. Another approach is to take the derivative (slope) of the smoothed acceleration signal. The derivative changes from negative to positive (or positive to negative) exactly when a step occurs, so you can just count the number of times the derivative changed from negative to positive to detect the number of steps that occurred.  Another possibility is to subtract the mean for each window and look at  zero crossings i.e. times when the signal crosses from the negative to positive in the upward direction (this can be tricky, however, since the signal baseline can change over time as shown below).</p>

<p>We will focus on detecting peaks using Python and tuning parameters to make it work effectively.</p>

<h2 id="implementing-step-counting-in-python">Implementing Step Counting in Python</h2>

<p>Step counting, at its core, is about detecting repeating patterns or peaks in acceleration data that correspond to an individual’s steps. In Python, the <code class="language-plaintext highlighter-rouge">scipy</code> library provides the <code class="language-plaintext highlighter-rouge">find_peaks</code> function that serves precisely this purpose, allowing us to detect peaks in our dataset easily.</p>

<h2 id="the-find_peaks-function">The <code class="language-plaintext highlighter-rouge">find_peaks</code> Function</h2>

<p>The <code class="language-plaintext highlighter-rouge">find_peaks</code> function from the <code class="language-plaintext highlighter-rouge">scipy.signal</code> module is designed for pinpointing the indices of relative maxima (peaks) in a 1D array. Its standard usage is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">find_peaks</span>

<span class="n">peaks</span><span class="p">,</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">data_array</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">ht</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prom</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">dist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">wid</span><span class="p">)</span>
</code></pre></div></div>

<p>For this function:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">data_array</code> is the time-series dataset where we aim to detect peaks.</li>
  <li><code class="language-plaintext highlighter-rouge">height</code> serves as a threshold that peaks must surpass for detection.</li>
  <li><code class="language-plaintext highlighter-rouge">prominence</code> designates how elevated a peak is in relation to its neighbors, emphasizing the peak’s relative prominence.</li>
  <li><code class="language-plaintext highlighter-rouge">distance</code> is the minimum horizontal separation (in data points) expected between peaks.</li>
  <li><code class="language-plaintext highlighter-rouge">width</code> refers to the width of the peaks at half-prominence.</li>
</ul>

<p>Note that for the assignment, we primarily ask you to work with <code class="language-plaintext highlighter-rouge">distance</code> rather than the other parameters.</p>

<p>For our step counting scenario:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">'accel_mag'</span><span class="p">],</span> <span class="n">height</span><span class="o">=</span><span class="n">ht</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prom</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">dist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">wid</span><span class="p">)</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
</code></pre></div></div>

<p>Here, we’re looking for peaks in the <code class="language-plaintext highlighter-rouge">accel_mag</code> column of our DataFrame, which symbolizes the magnitude of acceleration data. By counting these peaks, we get an estimate of the steps taken. However, without careful parameter tuning, this estimate can differ significantly from the true value.</p>

<h3 id="tuning-parameters-height-prominence-distance-and-width">Tuning Parameters: Height, Prominence, Distance, and Width</h3>

<ul>
  <li>
    <p><strong>Height:</strong> This threshold ensures only peaks exceeding a certain value are detected, helping to filter out minor fluctuations and zeroing in on significant movements.</p>
  </li>
  <li>
    <p><strong>Prominence:</strong> Useful in discerning genuine peaks from mere noise. A heightened prominence value ensures only peaks distinctly pronounced from their surroundings are identified. This precision is important for sidestepping minor data disturbances being misconceived as steps.</p>
  </li>
  <li>
    <p><strong>Distance:</strong> Crucial for step detection, the <code class="language-plaintext highlighter-rouge">distance</code> parameter corresponds to our understanding of the time lapse between two successive steps. For example, during regular walking, we usually register 1-2 steps every second. Adjusting the <code class="language-plaintext highlighter-rouge">distance</code> parameter helps in preventing the recognition of multiple peaks within a single step’s duration.</p>
  </li>
  <li>
    <p><strong>Width:</strong> The <code class="language-plaintext highlighter-rouge">width</code> parameter captures the full width of a peak at its half-prominence. This becomes particularly relevant in discerning between short spikes (possibly noise or artifacts) and genuine peaks of activity, like steps. In our context, <code class="language-plaintext highlighter-rouge">width</code> can reflect the typical duration of a step, and filtering peaks based on this duration can improve accuracy.</p>
  </li>
</ul>

<h3 id="the-role-of-sampling-rate">The Role of Sampling Rate</h3>

<p>Sampling rate, denoted as the number of samples gathered each second, is a cornerstone in peak detection. Given our earlier example of a 1-2 step walking rate:</p>

<ul>
  <li>With a 50 Hz sampling rate, a step might span 25 to 50 samples.</li>
  <li>At a 100 Hz sampling rate, a step could range from 50 to 100 samples.</li>
</ul>

<p>Clearly, the optimal values for parameters, especially <code class="language-plaintext highlighter-rouge">distance</code> and <code class="language-plaintext highlighter-rouge">width</code>, will vary with the sampling rate. Thus, when adjusting these parameters for <code class="language-plaintext highlighter-rouge">find_peaks</code>, it’s crucial to keep the sampling rate of your data in mind to ensure precise peak (step) detection.</p>

<h2 id="notebook-step-counting-with-find-peaks-html-ipynb">Notebook: Step Counting with Find Peaks [<a href="notebooks/Chapter2-StepCounting.html">html</a>] [<a href="notebooks/step-counting.zip">ipynb</a>]</h2>
<p>This notebook shows a step counter using <code class="language-plaintext highlighter-rouge">find_peaks</code> and applies it to a number of sample sensor logs. The different logs correspond to different sensor placements (left pocket, right pocket, wrist), and to different walking patterns (e.g. with delays between short burst of steps). The notebook shows how tweaking the <code class="language-plaintext highlighter-rouge">prominence</code> and <code class="language-plaintext highlighter-rouge">width</code> parameters can allow you to fine-tune the performance of the step counter.</p>

